"""g-vulnerability framework."""

from libqif.util.types import check_list, check_numpy_array
from numpy import arange, zeros, identity, array
from numpy import max as npmax

class Gain:

    def __init__(self, secrets, actions, gfunction):
        """Gain functions. It must be passed a pointer to a gain function or
        a matrix gain function. Both actions and secrets are referenced in
        gain attribute by their index in the lists secrets.labels and actions.

        Attributes
        ----------
        secrets : core.Secrets
            Set of secrets.

        actions : list
            Set of actions.

        num_actions : int
            Number of actions.

        gain : numpy.ndarray
            Gain function matrix. gain[w][x] is the gain the adversary gets
            when he takes the action actions[w] when the secret is 
            secrets.labels[x].

        Parameters
        ----------
        secrets : core.Secrets
            Set of secrets.

        actions : list
            Set of actions.

        gfunction : numpy.ndarray, pointer to a function
            A 2d matrix or a pointer to a function.
            If the value is a matrix, its shape must match with the actions
            and secrets sets size.
            If the value is a pointer to a function, the function must have
            2 input parameters (w,x), where w is the index of an element from
            the set of actions and x is an index of an element from the set
            of secrets.
        """

        self.secrets = secrets
        self.actions = check_list(actions)
        self.num_actions = len(self.actions)
        self.gain = None

        # Set Bayes vulnerability as the gain function
        try:
            if type(gfunction) == type(array([])):
                self._check_gain_matrix(gfunction)
                self.gain = gfunction.copy()
            else:
                self._build_gain_matrix(gfunction)
        except:
            print('Invalid gain function. It must be a pointer to a function ' +
                  'that has 2 input parameters (action\'s index and ' +
                  'secret\'s index) or a 2d matrix.')

    def prior_vulnerability(self):
        """Prior vulnerability.
        
        Returns
        -------
        prior_vulnerability : float
            Prior vulnerability.
        """
        return npmax(self.secrets.prior @ self.gain.T)
    
    def posterior_vulnerability(self, hyper):
        """Posterior vulnerability.

        Parameters
        ----------
        hyper : core.Hyper
            Hyper-distribution.

        Returns
        -------
        posterior_vulnerability : float
            Posterior vulnerability.
        """

        if hyper.secrets.num_secrets != gain.secrets.num_secrets:
            raise Exception('The number of secrets in the gain function is' +
                            'different from the one in the hyper-distribution.')

        return npmax(self.gain @ hyper.joint, axis=0).sum()

    def _build_gain_matrix(self, gfunction):
        """Given a function build the matrix."""
        self.gain = zeros((self.num_actions, self.secrets.num_secrets))
        
        for w in arange(self.num_actions):
            for x in arange(self.secrets.num_secrets):
                self.gain[w][x] = gfunction(w,x)
    
    def _check_gain_matrix(self, matrix):
        """Check if a gain function matrix is valid."""
        check_numpy_array(matrix)
        if (self.num_actions != matrix.shape[0] or
            self.secrets.num_secrets != matrix.shape[1]):
            raise Exception('Gain function matrix shape does not match with ' +
                            'the set of secrets or the set of actions size.')
        